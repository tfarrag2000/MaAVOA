import math

import numpy as np

from old_trials.levyFlight import levyFlight


def exploitation(current_vulture_X, Best_vulture1_X, Best_vulture2_X, random_vulture_X, F,
                 p2, p3, variables_no, upper_bound, lower_bound):
    # phase 1: Exploitation Stage (Medium)
    current_vulture_X=np.array(current_vulture_X,dtype=np.float32)
    if np.abs(F) >= 0.5:
        if np.random.rand() >= p2:
            # Competition for Food
            current_vulture_X = (np.abs((2 * np.random.rand()) * random_vulture_X - current_vulture_X)) * (
                    F + np.random.rand()) - (
                                        random_vulture_X - current_vulture_X)
        else:
            # Rotating flight of Vultures
            s1 = np.multiply(np.multiply(random_vulture_X, (np.random.rand() * current_vulture_X / (2 * math.pi))),
                             np.cos(current_vulture_X))
            s2 = np.multiply(np.multiply(random_vulture_X, (np.random.rand() * current_vulture_X / (2 * math.pi))),
                             np.sin(current_vulture_X))
            current_vulture_X = random_vulture_X - (s1 + s2)

    # phase 2: Exploitation Stage (Later)
    if np.abs(F) < 0.5:
        if np.random.rand() >= p3:
            # Aggregation behaviour
            t1 = (Best_vulture1_X - current_vulture_X) + 0.0000000001
            t2 = (Best_vulture2_X - current_vulture_X) + 0.0000000001

            if (not t1.any()) or (not t2.any()):
                pass
            else:
                A = Best_vulture1_X - ((np.multiply(Best_vulture1_X, current_vulture_X)) / (t1 ** 2)) * F
                B = Best_vulture2_X - ((np.multiply(Best_vulture2_X, current_vulture_X)) / (t2 ** 2)) * F
                current_vulture_X = (A + B) / 2
        else:
            # Attack behaviour
            current_vulture_X = random_vulture_X - np.multiply(np.abs(random_vulture_X - current_vulture_X) * F,
                                                               levyFlight(variables_no))

    return current_vulture_X
